/-
Copyright (c) 2025 ModularPhysics Contributors. All rights reserved.
Released under Apache 2.0 license.
Authors: ModularPhysics Contributors
-/
import OSReconstruction.vNA.ModularTheory
import OSReconstruction.vNA.Unbounded.Spectral

/-!
# Modular Automorphism Group

This file develops the theory of the modular automorphism group σ_t associated
with a cyclic-separating vector (or more generally, a faithful normal state).

## Main definitions

* `ModularAutomorphismGroup` - the one-parameter group σ_t(a) = Δ^{it}aΔ^{-it}
* `ConnesCocycle` - the Connes cocycle (Dφ : Dψ)_t relating different states

## Main results

* `ModularAutomorphismGroup.is_automorphism` - σ_t is a *-automorphism
* `ModularAutomorphismGroup.group_law` - σ_s ∘ σ_t = σ_{s+t}
* `ModularAutomorphismGroup.continuity` - t ↦ σ_t(a) is σ-weakly continuous
* `connes_cocycle_relation` - the cocycle identity

## References

* Takesaki, "Theory of Operator Algebras II", Chapter VIII
* Connes, "Une classification des facteurs de type III" (1973)
-/

noncomputable section

open scoped InnerProduct ComplexConjugate

universe u

variable {H : Type u} [NormedAddCommGroup H] [InnerProductSpace ℂ H] [CompleteSpace H]

namespace VonNeumannAlgebra

variable (M : VonNeumannAlgebra H)

/-! ### Modular automorphism group -/

/-- The modular automorphism group σ^φ_t associated with a faithful normal state φ
    (represented by a cyclic-separating vector Ω).
    σ_t(a) = Δ^{it} a Δ^{-it}

    This structure bundles:
    - The cyclic-separating vector Ω
    - The unbounded modular operator Δ (positive self-adjoint)
    - Proofs of the required properties for spectral theory -/
structure ModularAutomorphismGroup (Ω : H) where
  /-- The cyclic-separating vector defining the state -/
  vec : H
  /-- Proof that the vector is cyclic-separating -/
  cyclic_sep : M.IsCyclicSeparating Ω
  /-- The unbounded modular operator Δ = S̄*S̄ -/
  Δ : UnboundedOperator H
  /-- Δ is densely defined -/
  Δ_dense : Δ.IsDenselyDefined
  /-- Δ is self-adjoint -/
  Δ_selfadj : Δ.IsSelfAdjoint Δ_dense
  /-- Δ is positive -/
  Δ_pos : Δ.IsPositive
  /-- Δ^{it} fixes the cyclic vector for all t ∈ ℝ.
      This follows from ΔΩ = Ω (Ω is an eigenvector of Δ with eigenvalue 1),
      hence by spectral calculus f(Δ)Ω = f(1)Ω for any Borel function f,
      in particular Δ^{it}Ω = 1^{it}Ω = Ω. -/
  unitaryGroup_fixes_vec : ∀ t : ℝ, unitaryGroup Δ Δ_dense Δ_selfadj t Ω = Ω

namespace ModularAutomorphismGroup

variable {M} {Ω : H}

/-- The unitary group Δ^{it} generated by the modular operator -/
def unitaryAt (σ : ModularAutomorphismGroup M Ω) (t : ℝ) : H →L[ℂ] H :=
  unitaryGroup σ.Δ σ.Δ_dense σ.Δ_selfadj t

/-- The action of σ_t on an element a ∈ M.
    σ_t(a) = Δ^{it} a Δ^{-it} is the modular automorphism. -/
def apply (σ : ModularAutomorphismGroup M Ω) (t : ℝ) (a : H →L[ℂ] H) (_ : a ∈ M) :
    H →L[ℂ] H :=
  σ.unitaryAt t ∘L a ∘L σ.unitaryAt (-t)

/-- σ_t maps M to M. This is the Tomita-Takesaki fundamental theorem. -/
theorem preserves_algebra (σ : ModularAutomorphismGroup M Ω) (t : ℝ)
    (a : H →L[ℂ] H) (ha : a ∈ M) : σ.apply t a ha ∈ M := by
  -- Follows from Tomita-Takesaki fundamental theorem:
  -- Δ^{it} M Δ^{-it} = M for all t ∈ ℝ
  sorry

/-- σ_t preserves multiplication: σ_t(ab) = σ_t(a)σ_t(b).
    This follows from U(ab)U* = (UaU*)(UbU*) for unitary U. -/
theorem preserves_mul (σ : ModularAutomorphismGroup M Ω) (t : ℝ)
    (a b : H →L[ℂ] H) (ha : a ∈ M) (hb : b ∈ M) :
    σ.apply t (a ∘L b) (M.toStarSubalgebra.mul_mem ha hb) =
    σ.apply t a ha ∘L σ.apply t b hb := by
  -- Δ^{it}(ab)Δ^{-it} = (Δ^{it}aΔ^{-it})(Δ^{it}bΔ^{-it})
  -- Uses: Δ^{-it}Δ^{it} = 1 in the middle
  -- U(t) (ab) U(-t) = U(t) a (U(-t) U(t)) b U(-t) = (U(t) a U(-t)) (U(t) b U(-t))
  simp only [apply, unitaryAt]
  have hid : unitaryGroup σ.Δ σ.Δ_dense σ.Δ_selfadj (-t) ∘L
             unitaryGroup σ.Δ σ.Δ_dense σ.Δ_selfadj t = 1 :=
    unitaryGroup_neg_comp σ.Δ σ.Δ_dense σ.Δ_selfadj t
  ext x
  simp only [ContinuousLinearMap.comp_apply]
  -- RHS is U(t) (a (U(-t) (U(t) (b (U(-t) x)))))
  -- Insert U(-t) U(t) = 1 in the middle: a (U(-t) (U(t) (b ...))) = a (b ...)
  have h : (unitaryGroup σ.Δ σ.Δ_dense σ.Δ_selfadj (-t) ∘L
            unitaryGroup σ.Δ σ.Δ_dense σ.Δ_selfadj t) (b (unitaryGroup σ.Δ σ.Δ_dense σ.Δ_selfadj (-t) x))
           = b (unitaryGroup σ.Δ σ.Δ_dense σ.Δ_selfadj (-t) x) := by
    rw [hid]; simp
  simp only [ContinuousLinearMap.comp_apply] at h
  rw [h]

/-- σ_t preserves adjoints: σ_t(a*) = σ_t(a)*.
    Since Δ^{it} is unitary, (UaU*)* = Ua*U*. -/
theorem preserves_adjoint (σ : ModularAutomorphismGroup M Ω) (t : ℝ)
    (a : H →L[ℂ] H) (ha : a ∈ M) :
    σ.apply t (ContinuousLinearMap.adjoint a) (star_mem ha) =
    ContinuousLinearMap.adjoint (σ.apply t a ha) := by
  -- Δ^{it}a*Δ^{-it} = (Δ^{it}aΔ^{-it})*
  -- Uses: (UaU*)* = U**a*U* = Ua*U* (since U is unitary)
  simp only [apply, unitaryAt]
  -- (U(t) ∘L a ∘L U(-t))* = U(-t)* ∘L a* ∘L U(t)* = U(t) ∘L a* ∘L U(-t)
  rw [ContinuousLinearMap.adjoint_comp, ContinuousLinearMap.adjoint_comp,
      unitaryGroup_inv σ.Δ σ.Δ_dense σ.Δ_selfadj t,
      unitaryGroup_inv σ.Δ σ.Δ_dense σ.Δ_selfadj (-t), neg_neg]
  ext x; simp [ContinuousLinearMap.comp_apply]

/-- σ_t is an automorphism (bijective) with inverse σ_{-t} -/
theorem is_automorphism (σ : ModularAutomorphismGroup M Ω) (t : ℝ)
    (a : H →L[ℂ] H) (ha : a ∈ M) :
    σ.apply (-t) (σ.apply t a ha) (σ.preserves_algebra t a ha) = a := by
  -- σ_{-t}(σ_t(a)) = Δ^{-it}(Δ^{it}aΔ^{-it})Δ^{it} = a
  simp only [apply, unitaryAt]
  -- Use the inverse properties of the unitary group
  have hmul1 : unitaryGroup σ.Δ σ.Δ_dense σ.Δ_selfadj (-t) ∘L
               unitaryGroup σ.Δ σ.Δ_dense σ.Δ_selfadj t = 1 :=
    unitaryGroup_neg_comp σ.Δ σ.Δ_dense σ.Δ_selfadj t
  have hmul2 : unitaryGroup σ.Δ σ.Δ_dense σ.Δ_selfadj t ∘L
               unitaryGroup σ.Δ σ.Δ_dense σ.Δ_selfadj (-t) = 1 :=
    unitaryGroup_comp_neg σ.Δ σ.Δ_dense σ.Δ_selfadj t
  ext x
  simp only [ContinuousLinearMap.comp_apply, neg_neg]
  -- U(-t) U(t) a U(-t) U(t) x = a x since U(-t) U(t) = 1
  have step1 : (unitaryGroup σ.Δ σ.Δ_dense σ.Δ_selfadj (-t) ∘L
                unitaryGroup σ.Δ σ.Δ_dense σ.Δ_selfadj t) x = x := by
    rw [hmul1]; simp
  have step2 : (unitaryGroup σ.Δ σ.Δ_dense σ.Δ_selfadj (-t) ∘L
                unitaryGroup σ.Δ σ.Δ_dense σ.Δ_selfadj t) (a x) = a x := by
    rw [hmul1]; simp
  simp only [ContinuousLinearMap.comp_apply] at step1 step2
  rw [step1, step2]

/-- Group law: σ_s ∘ σ_t = σ_{s+t} -/
theorem group_law (σ : ModularAutomorphismGroup M Ω) (s t : ℝ)
    (a : H →L[ℂ] H) (ha : a ∈ M) :
    σ.apply s (σ.apply t a ha) (σ.preserves_algebra t a ha) =
    σ.apply (s + t) a ha := by
  -- Δ^{is}(Δ^{it} a Δ^{-it})Δ^{-is} = Δ^{i(s+t)} a Δ^{-i(s+t)}
  simp only [apply, unitaryAt]
  have hgroup := unitaryGroup_mul σ.Δ σ.Δ_dense σ.Δ_selfadj
  ext x
  simp only [ContinuousLinearMap.comp_apply]
  -- U(s) U(t) a U(-t) U(-s) x = U(s+t) a U(-(s+t)) x
  have h1 : unitaryGroup σ.Δ σ.Δ_dense σ.Δ_selfadj s ∘L
            unitaryGroup σ.Δ σ.Δ_dense σ.Δ_selfadj t =
            unitaryGroup σ.Δ σ.Δ_dense σ.Δ_selfadj (s + t) := hgroup s t
  have h2 : unitaryGroup σ.Δ σ.Δ_dense σ.Δ_selfadj (-t) ∘L
            unitaryGroup σ.Δ σ.Δ_dense σ.Δ_selfadj (-s) =
            unitaryGroup σ.Δ σ.Δ_dense σ.Δ_selfadj (-(s + t)) := by
    rw [hgroup (-t) (-s)]; ring_nf
  rw [← ContinuousLinearMap.comp_apply (unitaryGroup _ _ _ s),
      ← ContinuousLinearMap.comp_apply (unitaryGroup _ _ _ (-t)), h1, h2]

/-- σ_0 = id -/
theorem at_zero (σ : ModularAutomorphismGroup M Ω) (a : H →L[ℂ] H) (ha : a ∈ M) :
    σ.apply 0 a ha = a := by
  simp only [apply, unitaryAt]
  have h0 := unitaryGroup_zero σ.Δ σ.Δ_dense σ.Δ_selfadj
  simp only [neg_zero, h0]
  ext x; simp

/-- Strong continuity on a dense domain -/
theorem strong_continuous (σ : ModularAutomorphismGroup M Ω)
    (a : H →L[ℂ] H) (_ha : a ∈ M) (ξ : H) :
    Continuous (fun t : ℝ => σ.apply t a _ha ξ) := by
  -- t ↦ σ_t(a)ξ = U(t) a U(-t) ξ is norm continuous
  -- since t ↦ U(t)x is continuous for all x
  simp only [apply, unitaryAt]
  -- Goal: Continuous (fun t => U(t) (a (U(-t) ξ)))
  -- Step 1: t ↦ U(-t)ξ is continuous
  have h_neg_cont : Continuous (fun t : ℝ => unitaryGroup σ.Δ σ.Δ_dense σ.Δ_selfadj (-t) ξ) := by
    exact (unitaryGroup_continuous σ.Δ σ.Δ_dense σ.Δ_selfadj ξ).comp continuous_neg
  -- Step 2: t ↦ a(U(-t)ξ) is continuous (CLM is continuous)
  have h_mid_cont : Continuous (fun t : ℝ => a (unitaryGroup σ.Δ σ.Δ_dense σ.Δ_selfadj (-t) ξ)) :=
    a.continuous.comp h_neg_cont
  -- Step 3: Use ε/2 argument for t ↦ U(t)(a(U(-t)ξ))
  -- ‖U(t)(y(t)) - U(s)(y(s))‖ ≤ ‖y(t) - y(s)‖ + ‖U(t)(y(s)) - U(s)(y(s))‖
  rw [Metric.continuous_iff]
  intro s ε hε
  -- Get δ₁ from continuity of y = t ↦ a(U(-t)ξ) at s
  have hy_cont := Metric.continuous_iff.mp h_mid_cont s (ε / 2) (half_pos hε)
  obtain ⟨δ₁, hδ₁_pos, hδ₁⟩ := hy_cont
  -- Get δ₂ from continuity of t ↦ U(t)(y(s)) at s, where y(s) = a(U(-s)ξ)
  have hU_cont := unitaryGroup_continuous σ.Δ σ.Δ_dense σ.Δ_selfadj
                    (a (unitaryGroup σ.Δ σ.Δ_dense σ.Δ_selfadj (-s) ξ))
  have hU_at := Metric.continuous_iff.mp hU_cont s (ε / 2) (half_pos hε)
  obtain ⟨δ₂, hδ₂_pos, hδ₂⟩ := hU_at
  refine ⟨min δ₁ δ₂, lt_min hδ₁_pos hδ₂_pos, fun t ht => ?_⟩
  have ht₁ : dist t s < δ₁ := lt_of_lt_of_le ht (min_le_left _ _)
  have ht₂ : dist t s < δ₂ := lt_of_lt_of_le ht (min_le_right _ _)
  -- Triangle inequality:
  -- ‖U(t)(y(t)) - U(s)(y(s))‖ ≤ ‖U(t)(y(t)) - U(t)(y(s))‖ + ‖U(t)(y(s)) - U(s)(y(s))‖
  calc dist (unitaryGroup σ.Δ σ.Δ_dense σ.Δ_selfadj t
              (a (unitaryGroup σ.Δ σ.Δ_dense σ.Δ_selfadj (-t) ξ)))
            (unitaryGroup σ.Δ σ.Δ_dense σ.Δ_selfadj s
              (a (unitaryGroup σ.Δ σ.Δ_dense σ.Δ_selfadj (-s) ξ)))
      ≤ dist (unitaryGroup σ.Δ σ.Δ_dense σ.Δ_selfadj t
                (a (unitaryGroup σ.Δ σ.Δ_dense σ.Δ_selfadj (-t) ξ)))
             (unitaryGroup σ.Δ σ.Δ_dense σ.Δ_selfadj t
                (a (unitaryGroup σ.Δ σ.Δ_dense σ.Δ_selfadj (-s) ξ)))
        + dist (unitaryGroup σ.Δ σ.Δ_dense σ.Δ_selfadj t
                  (a (unitaryGroup σ.Δ σ.Δ_dense σ.Δ_selfadj (-s) ξ)))
               (unitaryGroup σ.Δ σ.Δ_dense σ.Δ_selfadj s
                  (a (unitaryGroup σ.Δ σ.Δ_dense σ.Δ_selfadj (-s) ξ))) :=
        dist_triangle _ _ _
    _ < ε / 2 + ε / 2 := by
        apply add_lt_add
        · -- ‖U(t)(y(t)) - U(t)(y(s))‖ = ‖y(t) - y(s)‖ since U(t) is isometric
          simp only [dist_eq_norm]
          rw [← map_sub]
          -- U(t) is an isometry: ‖U(t)x‖ = ‖x‖
          -- Proved via ⟨U(t)z, U(t)z⟩ = ⟨z, U(t)*U(t)z⟩ = ⟨z, z⟩
          have h_adj_comp : ContinuousLinearMap.adjoint (unitaryGroup σ.Δ σ.Δ_dense σ.Δ_selfadj t) ∘L
              unitaryGroup σ.Δ σ.Δ_dense σ.Δ_selfadj t = 1 := by
            rw [unitaryGroup_inv, unitaryGroup_neg_comp]
          have hiso : ∀ z : H, ‖unitaryGroup σ.Δ σ.Δ_dense σ.Δ_selfadj t z‖ = ‖z‖ := by
            intro z
            have h_inner : @inner ℂ H _ (unitaryGroup σ.Δ σ.Δ_dense σ.Δ_selfadj t z)
                                        (unitaryGroup σ.Δ σ.Δ_dense σ.Δ_selfadj t z)
                         = @inner ℂ H _ z z := by
              rw [← ContinuousLinearMap.adjoint_inner_right, ← ContinuousLinearMap.comp_apply,
                  h_adj_comp, ContinuousLinearMap.one_apply]
            rw [inner_self_eq_norm_sq_to_K, inner_self_eq_norm_sq_to_K] at h_inner
            -- h_inner : (↑‖U(t)z‖)^2 = (↑‖z‖)^2 in ℂ
            have h_sq : ‖unitaryGroup σ.Δ σ.Δ_dense σ.Δ_selfadj t z‖ ^ 2 = ‖z‖ ^ 2 := by
              exact_mod_cast h_inner
            nlinarith [norm_nonneg (unitaryGroup σ.Δ σ.Δ_dense σ.Δ_selfadj t z),
                        norm_nonneg z,
                        sq_nonneg (‖unitaryGroup σ.Δ σ.Δ_dense σ.Δ_selfadj t z‖ - ‖z‖)]
          rw [hiso, ← dist_eq_norm]
          exact hδ₁ t ht₁
        · exact hδ₂ t ht₂
    _ = ε := add_halves ε

/-- Continuity: t ↦ σ_t(a) is σ-weakly continuous.
    This means that for all ξ, η ∈ H, the function t ↦ ⟨ξ, σ_t(a)η⟩ is continuous.
    This follows from the strong continuity of the unitary group t ↦ Δ^{it}. -/
theorem sigma_weak_continuous (σ : ModularAutomorphismGroup M Ω)
    (a : H →L[ℂ] H) (_ha : a ∈ M) (ξ η : H) :
    Continuous (fun t : ℝ => @inner ℂ H _ ξ ((σ.apply t a _ha) η)) := by
  -- Uses strong continuity: t ↦ σ_t(a)η is continuous, then inner product is continuous
  exact Continuous.inner continuous_const (σ.strong_continuous a _ha η)

/-- The state φ_Ω is invariant under σ_t -/
theorem state_invariant (σ : ModularAutomorphismGroup M Ω) (t : ℝ)
    (a : H →L[ℂ] H) (ha : a ∈ M) :
    @inner ℂ H _ Ω ((σ.apply t a ha) Ω) = @inner ℂ H _ Ω (a Ω) := by
  -- ⟨Ω, σ_t(a)Ω⟩ = ⟨Ω, U(t) a U(-t) Ω⟩ = ⟨Ω, U(t)(aΩ)⟩ = ⟨U(t)*Ω, aΩ⟩ = ⟨U(-t)Ω, aΩ⟩ = ⟨Ω, aΩ⟩
  -- Uses: U(-t)Ω = Ω (unitaryGroup_fixes_vec) and U(t)* = U(-t) (unitaryGroup_inv)
  simp only [apply, unitaryAt, ContinuousLinearMap.comp_apply]
  rw [σ.unitaryGroup_fixes_vec (-t)]
  -- Goal: inner Ω (U(t) (a Ω)) = inner Ω (a Ω)
  -- Use: ⟨Ω, U(t)(aΩ)⟩ = ⟨U(t)*Ω, aΩ⟩ = ⟨U(-t)Ω, aΩ⟩ = ⟨Ω, aΩ⟩
  conv_lhs =>
    rw [show @inner ℂ H _ Ω (unitaryGroup σ.Δ σ.Δ_dense σ.Δ_selfadj t (a Ω)) =
         @inner ℂ H _ (ContinuousLinearMap.adjoint (unitaryGroup σ.Δ σ.Δ_dense σ.Δ_selfadj t) Ω)
           (a Ω) from by rw [ContinuousLinearMap.adjoint_inner_left]]
  rw [unitaryGroup_inv σ.Δ σ.Δ_dense σ.Δ_selfadj t, σ.unitaryGroup_fixes_vec (-t)]

end ModularAutomorphismGroup

/-! ### Connes cocycle -/

/-- The Connes cocycle (Dφ : Dψ)_t relating two faithful normal states φ and ψ.
    This structure bundles the modular automorphism groups for both states,
    which provide access to the modular operators Δ_φ and Δ_ψ. -/
structure ConnesCocycle (Ω₁ Ω₂ : H) where
  /-- Both vectors are cyclic-separating -/
  cyclic_sep₁ : M.IsCyclicSeparating Ω₁
  cyclic_sep₂ : M.IsCyclicSeparating Ω₂
  /-- The modular automorphism group for the first state -/
  σ₁ : ModularAutomorphismGroup M Ω₁
  /-- The modular automorphism group for the second state -/
  σ₂ : ModularAutomorphismGroup M Ω₂

namespace ConnesCocycle

variable {M} {Ω₁ Ω₂ : H}

/-- The cocycle (Dφ : Dψ)_t is a unitary in M for each t.
    Defined as u_t = Δ_φ^{it} Δ_ψ^{-it} (Connes' theorem).
    Here Δ_φ^{it} is σ₁.unitaryAt(t) and Δ_ψ^{-it} is σ₂.unitaryAt(-t). -/
def cocycle (c : ConnesCocycle M Ω₁ Ω₂) (t : ℝ) : H →L[ℂ] H :=
  c.σ₁.unitaryAt t ∘L c.σ₂.unitaryAt (-t)

/-- The cocycle is unitary: u_t* u_t = u_t u_t* = 1.
    Since u_t = Δ_φ^{it} Δ_ψ^{-it} and both factors are unitary,
    u_t* = Δ_ψ^{it} Δ_φ^{-it}, and u_t u_t* = u_t* u_t = 1. -/
theorem cocycle_unitary (c : ConnesCocycle M Ω₁ Ω₂) (t : ℝ) :
    ContinuousLinearMap.adjoint (c.cocycle t) ∘L c.cocycle t = 1 ∧
    c.cocycle t ∘L ContinuousLinearMap.adjoint (c.cocycle t) = 1 := by
  simp only [cocycle, ModularAutomorphismGroup.unitaryAt]
  -- u_t = U₁(t) U₂(-t), u_t* = U₂(-t)* U₁(t)* = U₂(t) U₁(-t)
  have hinv1 := unitaryGroup_inv c.σ₁.Δ c.σ₁.Δ_dense c.σ₁.Δ_selfadj t
  have hinv2 := unitaryGroup_inv c.σ₂.Δ c.σ₂.Δ_dense c.σ₂.Δ_selfadj (-t)
  -- adjoint(U₁(t) ∘L U₂(-t)) = adjoint(U₂(-t)) ∘L adjoint(U₁(t)) = U₂(t) ∘L U₁(-t)
  rw [ContinuousLinearMap.adjoint_comp]
  rw [hinv1, hinv2, neg_neg]
  -- Now need: (U₂(t) ∘L U₁(-t)) ∘L (U₁(t) ∘L U₂(-t)) = 1
  -- and (U₁(t) ∘L U₂(-t)) ∘L (U₂(t) ∘L U₁(-t)) = 1
  have h1_cancel := unitaryGroup_neg_comp c.σ₁.Δ c.σ₁.Δ_dense c.σ₁.Δ_selfadj t
  have h1_cancel' := unitaryGroup_comp_neg c.σ₁.Δ c.σ₁.Δ_dense c.σ₁.Δ_selfadj t
  have h2_cancel := unitaryGroup_neg_comp c.σ₂.Δ c.σ₂.Δ_dense c.σ₂.Δ_selfadj t
  have h2_cancel' := unitaryGroup_comp_neg c.σ₂.Δ c.σ₂.Δ_dense c.σ₂.Δ_selfadj t
  constructor
  · -- (U₂(t) ∘L U₁(-t)) ∘L (U₁(t) ∘L U₂(-t)) = 1
    ext x; simp only [ContinuousLinearMap.comp_apply, ContinuousLinearMap.one_apply]
    -- U₁(-t)(U₁(t)(U₂(-t) x)) = U₂(-t) x
    have : (unitaryGroup c.σ₁.Δ c.σ₁.Δ_dense c.σ₁.Δ_selfadj (-t) ∘L
            unitaryGroup c.σ₁.Δ c.σ₁.Δ_dense c.σ₁.Δ_selfadj t)
            (unitaryGroup c.σ₂.Δ c.σ₂.Δ_dense c.σ₂.Δ_selfadj (-t) x)
           = unitaryGroup c.σ₂.Δ c.σ₂.Δ_dense c.σ₂.Δ_selfadj (-t) x := by
      rw [h1_cancel]; simp
    simp only [ContinuousLinearMap.comp_apply] at this
    rw [this]
    -- U₂(t)(U₂(-t) x) = x
    have : (unitaryGroup c.σ₂.Δ c.σ₂.Δ_dense c.σ₂.Δ_selfadj t ∘L
            unitaryGroup c.σ₂.Δ c.σ₂.Δ_dense c.σ₂.Δ_selfadj (-t)) x = x := by
      rw [h2_cancel']; simp
    simpa [ContinuousLinearMap.comp_apply] using this
  · -- (U₁(t) ∘L U₂(-t)) ∘L (U₂(t) ∘L U₁(-t)) = 1
    ext x; simp only [ContinuousLinearMap.comp_apply, ContinuousLinearMap.one_apply]
    -- U₂(-t)(U₂(t)(U₁(-t) x)) = U₁(-t) x
    have : (unitaryGroup c.σ₂.Δ c.σ₂.Δ_dense c.σ₂.Δ_selfadj (-t) ∘L
            unitaryGroup c.σ₂.Δ c.σ₂.Δ_dense c.σ₂.Δ_selfadj t)
            (unitaryGroup c.σ₁.Δ c.σ₁.Δ_dense c.σ₁.Δ_selfadj (-t) x)
           = unitaryGroup c.σ₁.Δ c.σ₁.Δ_dense c.σ₁.Δ_selfadj (-t) x := by
      rw [h2_cancel]; simp
    simp only [ContinuousLinearMap.comp_apply] at this
    rw [this]
    -- U₁(t)(U₁(-t) x) = x
    have : (unitaryGroup c.σ₁.Δ c.σ₁.Δ_dense c.σ₁.Δ_selfadj t ∘L
            unitaryGroup c.σ₁.Δ c.σ₁.Δ_dense c.σ₁.Δ_selfadj (-t)) x = x := by
      rw [h1_cancel']; simp
    simpa [ContinuousLinearMap.comp_apply] using this

/-- The cocycle is in M. This follows from the Tomita-Takesaki theorem:
    Δ^{it} M Δ^{-it} = M, so Δ_φ^{it} Δ_ψ^{-it} ∈ M. -/
theorem cocycle_in_algebra (c : ConnesCocycle M Ω₁ Ω₂) (t : ℝ) :
    c.cocycle t ∈ M := by
  simp only [cocycle]
  -- This requires the Tomita-Takesaki theorem
  sorry

/-- Cocycle identity: (Dφ : Dψ)_{s+t} = (Dφ : Dψ)_s · σ^ψ_s((Dφ : Dψ)_t)
    This is the fundamental cocycle relation for Connes cocycles.
    Note: This requires the full cocycle definition with modular operators. -/
theorem cocycle_identity (c : ConnesCocycle M Ω₁ Ω₂)
    (σ₂ : ModularAutomorphismGroup M Ω₂) (s t : ℝ) :
    c.cocycle (s + t) =
    c.cocycle s ∘L σ₂.apply s (c.cocycle t) (c.cocycle_in_algebra t) := by
  -- (Dφ : Dψ)_{s+t} = (Dφ : Dψ)_s · σ^ψ_s((Dφ : Dψ)_t)
  -- This requires the proper cocycle definition
  sorry

/-- Chain rule: (Dφ : Dψ)_t · (Dψ : Dρ)_t = (Dφ : Dρ)_t.
    This requires consistency of the modular operator data across cocycles.
    Proof: Δ_φ^{it} Δ_ψ^{-it} · Δ_ψ^{it} Δ_ρ^{-it} = Δ_φ^{it} (Δ_ψ^{-it} Δ_ψ^{it}) Δ_ρ^{-it}
         = Δ_φ^{it} Δ_ρ^{-it} -/
theorem chain_rule (c₁ : ConnesCocycle M Ω₁ Ω₂) (Ω₃ : H)
    (c₂ : ConnesCocycle M Ω₂ Ω₃) (c₃ : ConnesCocycle M Ω₁ Ω₃) (t : ℝ)
    (h12 : c₁.σ₂ = c₂.σ₁) (h13 : c₁.σ₁ = c₃.σ₁) (h23 : c₂.σ₂ = c₃.σ₂) :
    c₁.cocycle t ∘L c₂.cocycle t = c₃.cocycle t := by
  -- Chain rule: Δ_φ^{it} Δ_ψ^{-it} · Δ_ψ^{it} Δ_ρ^{-it} = Δ_φ^{it} Δ_ρ^{-it}
  simp only [cocycle, ModularAutomorphismGroup.unitaryAt]
  -- Use the equality hypotheses to rewrite
  -- Use structural equality to rewrite unitaryAt terms
  -- h12 gives c₁.σ₂ = c₂.σ₁, so their unitaryAt match
  have hmid : unitaryGroup c₁.σ₂.Δ c₁.σ₂.Δ_dense c₁.σ₂.Δ_selfadj (-t) ∘L
              unitaryGroup c₂.σ₁.Δ c₂.σ₁.Δ_dense c₂.σ₁.Δ_selfadj t = 1 := by
    rw [h12]; exact unitaryGroup_neg_comp c₂.σ₁.Δ c₂.σ₁.Δ_dense c₂.σ₁.Δ_selfadj t
  -- h13 gives c₁.σ₁ = c₃.σ₁
  have hleft : unitaryGroup c₁.σ₁.Δ c₁.σ₁.Δ_dense c₁.σ₁.Δ_selfadj t =
               unitaryGroup c₃.σ₁.Δ c₃.σ₁.Δ_dense c₃.σ₁.Δ_selfadj t := by
    rw [h13]
  -- h23 gives c₂.σ₂ = c₃.σ₂
  have hright : unitaryGroup c₂.σ₂.Δ c₂.σ₂.Δ_dense c₂.σ₂.Δ_selfadj (-t) =
                unitaryGroup c₃.σ₂.Δ c₃.σ₂.Δ_dense c₃.σ₂.Δ_selfadj (-t) := by
    rw [h23]
  ext x
  simp only [ContinuousLinearMap.comp_apply]
  -- LHS: U₁_σ₁(t) (U₁_σ₂(-t) (U₂_σ₁(t) (U₂_σ₂(-t) x)))
  -- Cancel middle: U₁_σ₂(-t) (U₂_σ₁(t) y) = y
  have hcancel : ∀ y, (unitaryGroup c₁.σ₂.Δ c₁.σ₂.Δ_dense c₁.σ₂.Δ_selfadj (-t) ∘L
                  unitaryGroup c₂.σ₁.Δ c₂.σ₁.Δ_dense c₂.σ₁.Δ_selfadj t) y = y := by
    intro y; rw [hmid]; simp
  simp only [ContinuousLinearMap.comp_apply] at hcancel
  rw [hcancel]
  -- Now: U₁_σ₁(t) (U₂_σ₂(-t) x) = U₃_σ₁(t) (U₃_σ₂(-t) x)
  rw [hleft, hright]

/-- (Dφ : Dφ)_t = 1 when the modular operators are the same.
    Since u_t = Δ^{it} Δ^{-it} = 1. -/
theorem self_trivial (c : ConnesCocycle M Ω₁ Ω₁) (t : ℝ) (h : c.σ₁ = c.σ₂) :
    c.cocycle t = 1 := by
  simp only [cocycle, ModularAutomorphismGroup.unitaryAt, h]
  -- Δ^{it} Δ^{-it} = 1
  rw [unitaryGroup_mul, add_neg_cancel, unitaryGroup_zero]

/-- Relation between modular automorphisms:
    σ^φ_t(a) = (Dφ : Dψ)_t · σ^ψ_t(a) · (Dφ : Dψ)_t*
    This requires the full cocycle definition relating the two modular operators. -/
theorem modular_relation (c : ConnesCocycle M Ω₁ Ω₂)
    (σ₁ : ModularAutomorphismGroup M Ω₁) (σ₂ : ModularAutomorphismGroup M Ω₂)
    (t : ℝ) (a : H →L[ℂ] H) (ha : a ∈ M) :
    σ₁.apply t a ha =
    c.cocycle t ∘L σ₂.apply t a ha ∘L ContinuousLinearMap.adjoint (c.cocycle t) := by
  -- σ^φ_t(a) = (Dφ : Dψ)_t · σ^ψ_t(a) · (Dφ : Dψ)_t*
  -- This requires the proper cocycle definition: u_t = Δ_φ^{it} Δ_ψ^{-it}
  sorry

end ConnesCocycle

/-! ### Inner automorphisms -/

/-- An automorphism α of M is inner if α(a) = uau* for some unitary u ∈ M -/
def IsInnerAutomorphism (α : (H →L[ℂ] H) → (H →L[ℂ] H)) : Prop :=
  ∃ u : H →L[ℂ] H, u ∈ M ∧
    (ContinuousLinearMap.adjoint u ∘L u = 1) ∧
    (u ∘L ContinuousLinearMap.adjoint u = 1) ∧
    ∀ a ∈ M, α a = u ∘L a ∘L ContinuousLinearMap.adjoint u

/-- A unitary element in M -/
structure UnitaryElement where
  val : H →L[ℂ] H
  mem : val ∈ M
  unitary_left : ContinuousLinearMap.adjoint val ∘L val = 1
  unitary_right : val ∘L ContinuousLinearMap.adjoint val = 1

/-- σ_t is inner iff there exists a unitary u_t ∈ M with σ_t(a) = u_t a u_t* -/
theorem modular_inner_iff (σ : ModularAutomorphismGroup M Ω) (t : ℝ) :
    IsInnerAutomorphism M (fun a => σ.apply t a (by
      -- We need membership proof; this is a characterization theorem
      sorry)) ↔
    ∃ u : UnitaryElement M,
      ∀ a ∈ M, σ.apply t a (by sorry) = u.val ∘L a ∘L ContinuousLinearMap.adjoint u.val := by
  -- This characterizes when the modular automorphism is inner
  sorry

/-! ### Approximate innerness (Connes) -/

/-- The modular automorphism group is approximately inner:
    for any ε > 0 and finite set F ⊆ M, there exists unitary u ∈ M such that
    ‖σ_t(a) - uau*‖ < ε for all a ∈ F (Connes' theorem) -/
theorem approximately_inner (σ : ModularAutomorphismGroup M Ω) (t : ℝ)
    (ε : ℝ) (_hε : 0 < ε) (F : Finset (H →L[ℂ] H)) (hF : ∀ a ∈ F, a ∈ M) :
    ∃ u : UnitaryElement M, ∀ a : H →L[ℂ] H, ∀ ha : a ∈ F,
      ‖σ.apply t a (hF a ha) - u.val ∘L a ∘L ContinuousLinearMap.adjoint u.val‖ < ε := by
  -- Connes' approximate innerness theorem
  sorry

end VonNeumannAlgebra
